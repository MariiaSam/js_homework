У JavaScript існують такі типи даних:
Основні типи даних:

Boolean - логічний (булевий) тип даних: true і false

Number числа цілі, наприклад: 3 або з плаваючою крапкою наприклад: 1.6

String - рядок, символьний тип даних, тобто послідовність символів.

Symbol - примітивний тип даних (новий тип даних який появився в специфікації ES6)

Спеціальний тип даних:
undefined - зміна якій не присвоїли значення.
null - нулєве значення, "пусте значення".


===============================================
Для визначення типу використовують typeof.
typeof - повертає текстову назву типу даних.

===============================================
`` - шаблоні рядки.

Синтаксис:
var s = `текст шаблона`;
Параметри:
s - змінна які присвоюється рядок.

Опис:
`` шаблоний рядок (шаблоний літерал) який дозволяє створювати рядок за вказаним шаблоном.

Можливі вказувати в шаблонні:
вираз. Дозволяє вставляти вирази: змінні, функції і т.п. у рядок: ${вираз}
var a=12;
var s = `тест ${a}`;
alert(s);
розрив рядків. Дозволяє створювати рядки з розривами.
var s = `рядок 1
рядок 2
рядок 3`;
alert(s);
Шаблоні рядки можна передавати функціям без дужок:

==============================================
JavaScript: Конкатенация
В веб-разработке программы постоянно оперируют строками. 
Всё, что мы видим на сайтах, так или иначе представлено в виде текста.
Этот текст чаще всего динамический, то есть полученный из разных частей, которые соединяются вместе. Операция соединения строк в программировании называется конкатенацией.

// Оператор такой же, как и при сложении чисел
// но здесь он имеет другой смысл (семантику)
console.log('Dragon' + 'stone');
// => Dragonstone
Склеивание строк всегда происходит в том же порядке, в котором записаны операнды. Левый операнд становится левой частью строки, а правый — правой.

==============================================
Boolean
У JavaScript існує логічний тип даних Boolean і об'єкт Boolean.

Boolean як логічний тип даних.
Bolean - логічний (булевий) тип даних. Примітивний тип даних в інформатиці , 
що може приймати два можливих значення, що іноді називаються істиною(true) і хибою(false) (так і ні).

Приклад присвоєння зміні true.


var a=true; //зміні a присвоюється true

Присвоювати зміні можна і порівняння.


x= 5>3; //зміні x присвоює true

var a=4, b=6;
a=(a+b)/2;
x=a<b; //x присвоюємо true, так як a менше b

Логічний тип даних перевіряється на true чи false умовним оператором if. Приклад перевірки логічного типу:


var x=true;

if(x==true) alert('істина');
else alert('хиба');

Boolean як об'єкт.
Об'єкт Boolean являється оболонкою логічного типу даних Boolean.

Синтаксис об'єкта Boolean:
bol=new Boolean([value]);
Параметри:
bol зміна якій буде присвоєно об'єкт Boolean.

value не обов'язковий параметр. Значення об'єкта.

Опис:
При створені об'єкта значення value перетворюється у логічний тип даних. Якщо значення value не вказано або дорівнює 0, false, Nan, undefined, null, порожній рядок "" тоді value дорівнює false інакше true.


var x= new Boolean(false); //false
var x= new Boolean(0); //false
var x= new Boolean(-0); //false
var x= new Boolean(""); //false
var x= new Boolean(null); //false
var x= new Boolean(NaN); //false
var x= new Boolean(undefined); //false

var x= new Boolean(true); //true
var x= new Boolean(1); //true
var x= new Boolean(16); //true
var x= new Boolean('текст'); //true
var x= new Boolean('false'); //true
var x= new Boolean({}); //true
var x= new Boolean([]); //true
var x= new Boolean('false'); //true

Не слід плутати значення логічного типу true і false зі значеннями об'єкту Boolean true і false.

Не використовуйте об'єкт Boolean замість логічного типу даних. 
Адже умовний оператор if любий об'єкт вважає як true.


var x= Boolean(false);
var y= new Boolean(false); //об'єкту присвоюємо false

if(x) alert('x = true');
if(y) alert('y = true'); // хоч і об'єкту присвоєно false, оператор if об'єкт вважає як true;

Якщо уже використовуєте об'єкт Boolean то при використанні умовного оператора щодо об'єкту 
використовуйте умовне порівняння == або ще краще ===. Приклад правильного порівняння у умовному операторі if для об'єкта Boolean:


var y= new Boolean(false);

if(y) alert('y = true');
if(y==true) alert('y == true'); 
if(y==false) alert('y = false');

У явному JavaScript-програмуванню об'єкт Boolean не використовується, а використовують логічний тип даних.

Методи:
Boolean.toString() - повертає рядкове представлення об'єкту.
Boolean.valueOf() - повертає примітивне значення об'єкта.

===========================================
NaN
Глобальна властивість NaN є значенням, представляюче не число (Not-A-Number).

Синтаксис:
NaN
Опис:
NaN є властивістю глобального об'єкта. Початковим значенням NaN є не-число (Not-A-Number) - те ж саме значення має Number.NaN.

В сучасних браузерах NaN є не зміною властивістю. Навіть коли це не так, уникайте її перевизначення.

У коді NaN використовується рідко. Вона виникає коли математичні функції не можуть повернути значення
 (наприклад, при виклику Math.sqrt(-1)) або коли функція зчитування числа з рядка не може це зробити,
  тому що в рядку не число (parseInt ( 'ляляля')).

Перевірка NaN на рівність оператором рівності (== і ===) не можуть використовуватися для NaN. 
Замість них використовуйте функції Number.isNaN() або isNaN().

Приклад:
var n=Number('5# @');
alert(n); //NaN

n = Math.sqrt(-1);
alert(n); //NaN

Зверніть увагу що typeof(NaN) видає number.

var x=5*'Текст';
alert(x); //NaN
alert(typeof(x)); //number

NaN === NaN ; // false
Number.NaN === NaN ; // false
isNaN(NaN); // true
isNaN(Number.NaN); // true


===========================================

Логічні оператори
У JavaScript є три логічні оператори:
&& (І) шукає зліва і справа ТРУ значення, тільки в такому випадку він буде повертати його
Або останнє, що було конвертоване до тру.
Якщо, наприклад, всі декілька значень тркʼу, то обираємо останній
Якщо в середені є фолс, то на ньому зупиняємось

ПРІОРІТЕТНІСТЬ
&& оператор має ЗАВЖДИ ПРІОРІТЕТ, спочатку виконує свою дію, 
а тільки тоді виконуємо порівняння
 

|| (АБО) шукає перше значення до тру і повертає його, або останнє
реагує на всі 6 булевих значень - БУЛЕВИЙ ФОЛС


! (НЕ)

&&
&& логічний оператор І (AND).

?? оператор нульового порівння, обирає б-я значення, яке не є 
null/undefined.
Реагує тільки на null/undefined!!!, тобто (фалс ?? 7 ___ обире фалс) Все інше його задвольняє
Видає перший, якщо це не null/undefined!!!



якщо в консоль вводимо б-я значення,
яке не null або андефайн,  
якщо першим операндом ставимо null/undefined - воно буде проігнороване
і переходимо до нвступного значення

Повертає true якщо два значення рівні true, інакше повертає false.

При порівняні:
true && true дає true
true && false дає false
false && true дає false
false && false дає false
var a = true, b = false;
alert( a && b ); //false
console.log( true && true); //true
console.log( false && true); //false
console.log( false && false); //false
console.log( true && true && true ); //true
console.log( true && true && false ); //false

||
|| логічний оператор АБО (OR).

Повертає true якщо одне значення рівне true, інакше повертає false.

При порівняні:
true || true дає true
true || false дає true
false || true дає true
false || false дає false
var a = true, b = false;
alert( a || b ); //true
console.log( true || true); //true
console.log( false || true); //true
console.log( false || false); //false
console.log( true || true || true ); //true
console.log( true || true || false ); //true

!
! логічний оператор НЕ (NOT).

Якщо оператор NOT застовується до булевого значення то повертає протилежне значення. Тобто якщо до true - поверне false, якщо до false - true.
alert( !false ); //true
alert( !true ); //false
var a = true;
var b = !a;
alert( b ); //false
Якщо застосовується до не булевого значення то спочатку переводить в булове значення, а потім повертає протилежне.

console.log(!true); //false
console.log(!false); //true
console.log(!undefined); // true
console.log(!null); // true
console.log(!20); //false
console.log(!0); //true
console.log(!NaN); //true
console.log(!{}); // false
console.log(!''); //true
console.log(!'Text'); //false
Також використовується подвійне заперечення !!. Використовується щоб перетворити значення до болевого.

alert( !!true );
var a;
var b=!!a;
alert( b ); //false
Якщо використовувати декілька логічних операторів то JavaScript використовує пріоритети для логічних операторів, тобто порядок їх виконання.

Пріоритети логічного оператора:
! (NOT)
&& (AND)
|| (OR)
Приклад:
var a=true, b=true;
if( a && b)
  alert('a та b істина');
function hello(name){
  name=name || 'анонім';
  alert('Привіт '+name);
}

hello();

================

Вирази та оператори
У цій главі описано всі оператори, вирази та ключові слова мови JavaScript.

Вирази та оператори за категоріями
Перелік в алфавітному порядку див. на бічній панелі ліворуч.

Первинні вирази
Основні ключові слова та загальні вирази в JavaScript. Ці вирази мають найвищий пріоритет (вищий за оператори ).

this
Ключове thisслово відноситься до спеціальної властивості контексту виконання.

Літерали
Основні null, логічні, числові та рядкові літерали.

[]
Синтаксис ініціалізатора масиву/літерала.

{}
Синтаксис ініціалізатора об’єкта/літерала.

function
Ключове functionслово визначає вираз функції.

class
Ключове classслово визначає вираз класу.

function*
Ключове function*слово визначає вираз функції генератора.

async function
Визначає async functionасинхронний вираз функції.

async function*
Ключові async function*слова визначають вираз функції асинхронного генератора.

/ab+c/i
Синтаксис літералів регулярного виразу.

`string`
Синтаксис літералу шаблону.

( )
Оператор групування.

Лівосторонні вирази
Ліві значення є призначенням призначення.

Аксесуари власності
Оператори-члени надають доступ до властивості або методу об’єкта ( object.propertyі object["property"]).

?.
Необов’язковий оператор ланцюжка повертає undefinedзамість того, щоб викликати помилку, якщо посилання є нульовим ( nullабо undefined).

new
Оператор newстворює екземпляр конструктора.

new.target
У конструкторах new.targetпосилається на конструктор, який був викликаний new.

import.meta
Об’єкт, що надає контекстно-залежні метадані модулю JavaScript.

super
Ключове superслово викликає батьківський конструктор або дозволяє отримати доступ до властивостей батьківського об’єкта.

import()
Синтаксис import()дозволяє асинхронно та динамічно завантажувати модуль у потенційно немодульне середовище.

Приріст і декремент
Оператори постфіксного/префіксного приросту та постфіксного/префіксного декременту.

A++
Постфіксний оператор приросту.

A--
Постфіксний оператор декременту.

++A
Префіксний оператор приросту.

--A
Префіксний оператор декременту.

Унарні оператори
Унарна операція — це операція лише з одним операндом.

delete
Оператор deleteвидаляє властивість з об’єкта.

void
Оператор voidобчислює вираз і відкидає його повернуте значення.

typeof
Оператор typeofвизначає тип даного об'єкта.

+
Унарний оператор плюс перетворює свій операнд на числовий тип.

-
Унарний оператор заперечення перетворює свій операнд на числовий тип, а потім заперечує його.

~
Побітовий оператор NOT.

!
Логічний оператор НЕ.

await
Призупиніть і відновіть асинхронну функцію та дочекайтеся виконання/відхилення обіцянки.

Арифметичні оператори
Арифметичні оператори приймають числові значення (літерали або змінні) як свої операнди та повертають єдине числове значення.

**
Оператор піднесення до степеня.

*
Оператор множення.

/
Оператор ділення.

%
Оператор залишку.

+(плюс)
Оператор додавання.

-
Оператор віднімання.

Оператори відношення
Оператор порівняння порівнює свої операнди та повертає логічне значення на основі того, чи порівняння вірне.

<(менше ніж)
Менше оператора.

>(Більш чим)
Більше ніж оператор.

<=
Оператор менше або рівно.

>=
Оператор «більше або рівно».

instanceof
Оператор instanceofвизначає, чи є об'єкт екземпляром іншого об'єкта.

in
Оператор inвизначає, чи має об'єкт задану властивість.

Примітка: => це не оператор, а позначення для функцій зі стрілками .

Оператори рівності
Результат обчислення оператора рівності завжди має логічний тип залежно від того, чи є порівняння істинним.

==
Оператор рівності.

!=
Оператор нерівності.

===
Оператор строгої рівності.

!==
Оператор суворої нерівності.

Оператори побітового зсуву
Операції зсуву всіх бітів операнда.

<<
Оператор побітового зсуву вліво.

>>
Оператор побітового зсуву вправо.

>>>
Побітовий беззнаковий оператор зсуву вправо.

Бінарні побітові оператори
Побітові оператори розглядають свої операнди як набір із 32 бітів (нулів і одиниць) і повертають стандартні числові значення JavaScript.

&
Побітове І.

|
Порозрядне АБО.

^
Побітове XOR.

Бінарні логічні оператори
Логічні оператори реалізують булеві (логічні) значення та мають поведінку короткого замикання .

&&
Логічне І.

||
Логічне АБО.

??
Нульовий оператор об’єднання.

Умовний (трійковий) оператор
(condition ? ifTrue : ifFalse)
Умовний оператор повертає одне з двох значень на основі логічного значення умови.

Оператори присвоювання
Оператор присвоєння присвоює значення лівому операнду на основі значення правого операнда.

=
Оператор присвоювання.

*=
Завдання на множення.

/=
Призначення поділу.

%=
Присвоєння залишку.

+=
Присвоєння доповнення.

-=
Віднімання завдання

<<=
Призначення лівого зсуву.

>>=
Призначення правої зміни.

>>>=
Присвоєння правого зсуву без знаку.

&=
Порозрядне присвоєння І.

^=
Порозрядне призначення XOR.

|=
Порозрядне присвоєння АБО.

**=
Присвоєння степеня.

&&=
Логічне присвоєння І.

||=
Логічне присвоювання АБО.

??=
Нульове об’єднане призначення.

[a, b] = arr,{ a, b } = obj
Присвоєння деструктуризації дозволяє призначати властивості масиву або об’єкта змінним за допомогою синтаксису, схожого на літерали масиву чи об’єкта.

Оператори дохідності
yield
Призупинити та відновити функцію генератора.

yield*
Делегувати іншу функцію генератора або ітерований об’єкт.

Синтаксис поширення
...obj
Синтаксис розповсюдження дозволяє розгорнути ітерацію, таку як масив або рядок, у місцях, де очікується нуль або більше аргументів (для викликів функцій) або елементів (для літералів масиву). У літералі об’єкта синтаксис розповсюдження перераховує властивості об’єкта та додає пари ключ-значення до створюваного об’єкта.

Оператор кома
,
Оператор коми дозволяє обчислювати кілька виразів в одному операторі та повертає результат останнього виразу.

=============

/***** Значення які завжди будуть конвертовані до false (Обов'язково!!!) *****/

//  0 (число нуль)
// console.log(Boolean(0));
// // "" (порожній рядок)
// console.log(Boolean(''));
// // NaN
// console.log(Boolean(NaN));
// // undefined
// console.log(Boolean(undefined));
// // null
// console.log(Boolean(null));
// // false
// console.log(Boolean(false));

null
Значення null є літералом JavaScript а не властивістю глобального об'єкта, як undefined. null представляє нульове або «порожній» значення, тобто, коли немає ніякого об'єктного значення.

null можна сказати навіть не тип даних це просто спеціальне значення яке має смисл "нічого" або "невідоме значення".

Значення null веде себе як 0 у числовому значені і як false у логічному.


var x = null;

var y=null*3; // x = 0, так як 0*3=0

Так як JavaScript чутливий до регістру то Null, nUll, nuLL і т.д. уже "не є" null, а може використовуватися при назві зміної, функції тощо.

При перевірці null і undefined враховуйте різницю між == і ===.


null==undefined //true
null===undefined //false

Щоб привести до Буля, с=можа вик-ти подвійну інверсію (!!``)
Оператор інверсія ! розвертає, все що було тру-фолс і навпаки, фолс-тру


========================
/***** Методи для роботки з числами (тип даних Number) *****/

// const str = '25.7a32px';
// Number.parseInt() - методом відбирається ціле число 25
// console.log(Number.parseInt(str));


// Number.parseFloat(25.68аропвоп666)
// console.log(Number.parseFloat(str)); відбираємо не ціле число, але безпечно до елемента,
 який не моде бути прирівнений до числа

// Number.isNaN()  та метод isNaN()
// const num = Number(str) // NaN  



// console.log(Number.isNaN(num)); перевіряє чи йому фактично прийшло значення
NOT NUMBER, тобто під тип даних NaN, не робить примусову конвертацію до числа 
і він перевіряє *тут NaN, ні тут не NaN, до нас прийшов тип даних, наприклад, - 
СТРІНГ*, він каже, *тут не має такого типу даних*
Хоче отримати готовий NaN (нот намбер), як значення.
Він дивиться чи фактично йому прийшов NaN, якщо йому прийшов NaN,
то він поверне ТРУ,
якщо б-щ інше =, то ФОЛС, сам він не вмє конвертувати

   
// console.log(isNaN(num)); сам спочатку конвертує до числа, 
а потім даний результат він вже перевіряє

// console.log('=====================================');

=========================
/***** Методи та властивості для роботки з рядками (тип даних String) *****/


ОБОВʼЯЗКОВО СТАВИМО !!!!!!!str!!!!!!!!

// const str = 'Hello world';
// // length
// console.log(str.length); вимірювання символів в рядку


// // toLowerCase()
// console.log(str.toLowerCase()); приводить все до нижнього регістру


// // toUpperCase()
// console.log(str.toUpperCase()); приводить до верхнього регістру

// indexOf() повертає індекс елемента, якщо він знаходить його в рядку,
тобто шукає підрядочка в рядку,
якщоний елемент не було знайдено, нам повертається -1,
повертається перший неможливий індекс елемента, (індекси завжди починаються з )) 

// console.log(str.indexOf(' '));
// console.log(str.indexOf('H'));

// console.log(str.includes('world'));  метод, який повертає готове Булеве значення, ТРУ або ФОЛС,
є такий елемент в нашому рядку чи немає

// const str = 'Hello world';


// endsWith() перевіряє чи наш рядок закінчується на такий елемент 
отримуємо значення ТРУ або ФОЛС
// console.log(str.endsWith(' world'));

// startsWith() перевіряє чи рядок починається з певного елемента
// console.log(str.startsWith('h'));

// replace() замінити перше спвівпадіння в нашому рядку, замінює перший елемент який співпаде, інші ігнорує,
якщо нет знайде, то нічого не відбудеться
// console.log(str.replace('l', '🍕')); 'l' замінити  '🍕'

// console.log(str);

// // replaceAll() змінить всі елементи, які співпадають до нашого пошуку
// console.log(str.replaceAll('l','🍟'));
// slice()

// console.log(str.slice(0, 5)); (0 - початок рядка, 5 до якого елемента не включно потрібно вирізати)
відрізати штакок рядка, 
та повернуто його
/ console.log(str.slice(0, str.length-1)) все виріжеться без останньої літери
// console.log(str);

===================================
===================================